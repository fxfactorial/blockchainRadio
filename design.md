First of all, I had to obtain a feed of transactions occuring within the Bitcoin peer-to-peer network. These transactions are not yet confirmed into the blockchain, or ledger, but rather hang around in a pool of other unconfirmed transactions for a while. Getting this data directly from a node listening on this network could prove to be a challenge, but fortunately, blockchain explorers like Blockchain.info offer a convenient method to browse transactions, whether confirmed or unconfirmed. Even more conveniently, within their selection of APIs, they offer a Websocket API (https://blockchain.info/api/api_websocket). A websocket allows for a real-time connection with an external server to receive streaming data. In my case, in my Javascript, I open a connection with wss://ws.blockchain.info/inv (note the syntax for a Websocket URI). 

I then send some messages through the socket telling blockchain.info what data I'm interested in receiving: '{"op":"unconfirmed_sub"}' to subscribe to unconfirmed transactions and '{"op":"blocks_sub"}' to subscribe to new block events, which occur when a miner confirms a group of transactions into a block. I send these messages as JSON encoded in strings. From there, the server will send messages (JSON strings again) to me in real-time when these events occur. In my Javascript, I set up an event handler "onmessage" which responds whenever a message is sent from blockchain.info to my websocket. I would have liked to incorporate other cryptocurrencies into this project, like Ethereum, but I didn't find similiar open Websocket APIs like Blockchain.info's for other coins.

After figuring the core of how I receive data, I realized that I only needed a client-side portion of my app. No data is being stored, and is rather being streamed in from a third-party service. Therefore, the "server" was essentially already implemented, and browser Javascript offered all the tools I need to open up Websocket connections and work with that data. I also decided against using something like Bootstrap for design purposes, since my page layout is minimalistic, with most attention centered on just one element in the middle. I implemented a visual to go along with my audio consisting of a circle within which transaction values would appear live. Occassionally, these values overflowed the circle, but having the circle auto-resize constantly looked jarring. I had the circle change colors (using CSS and JS) randomly on each transaction received to draw attention and better represent transaction velocity within the Bitcoin network. I decided to have the interface require minimal user interaction, to allow for a streaming radio type of experience. I experimented with allowing the user to change the instrument with a dropdown menu, but decided against it since most of the instruments sounded terrible. All of this greatly simplified my app architecture, which could remain minimalistic, consisting of only HTML, CSS, and vanilla JS.

Then, I needed to decide how to utilize the JSON data received from the API to the purpose of synthesizing music. I decided to use transaction value to determine the pitch of the notes that would play on transactions. Transaction value seemed like the most important metric a user might want to know about a Bitcoin transaction, as compared to more technical details like the size of the transaction in kilobytes. Together with transaction velocity, which can be ascertained from the tempo of the music, this would provide a good understanding of what's going on on the Bitcoin network at the moment. Unfortunately, this transaction value is not directly returned by the API. Each Bitcoin transaction consists of a set of inputs (which were outputs of a previous transaction) and another set of outputs. I calculated the transaction value by looping over the transaction inputs and adding up their values. This can be slightly misleading. Bitcoin transactions include a concept of "change," where excess coin you don't want to send returns to yourself. However, there's no way to determine which output of the transaction is going back to another address controller by the initiator (change), so summing inputs/outputs is the best approximation of value possible.

Using this transaction value, I developed a scale to convert into a pitch/frequency, mostly through trial and error by ear. Initially, the outputted audio sounded odd due to Bitcoin transaction values having a very large standard deviation. Many transaction contained close to zero in value while other included large sums. The audio was very distorted at the end ranges and consisted of many high pitches and low pitches. I decided to use a logarithmic scale instead to more evenly distribute the Bitcoin transactions among musical notes. I took the log base 10 of the transaction total value, and then placed it into a category (0-4, 4-5, etc). Again, the specific categorys and notes were determine by trial and error, seeing what sounded pleasing. Now all the transaction values between 10^6 and 10^7 would be assigned one note ("D", in this case), resulting in a more even distribution of notes with such extreme transaction values. I arranged this logic into a series of if-statements, which looked a bit verbose initially, since a switch wouldn't work smoothly in checking these conditions. It turns out regular if-statements are indeed the fastest solution (https://stackoverflow.com/questions/6665997/switch-statement-for-greater-than-less-than).

As for actually playing the pitch, I was debating a few approaches. One would be to have precomposed audio files for each note with an instrument of choice. The other would be to programatically synthesize the note/frequency. I decided to go with synthesis, but it turns out audio synthesis (and working with audio in general) in JavaScript can get complicated, involving the math of modeling appropriate sin wavs, opening buffers to write into, etc. Avoiding doing this manually, I first attempted using a library designed for this sort of synthesis called AudioSynth (https://github.com/keithwhor/audiosynth). I set up an instrument object and used it to play notes, which accomplished through the Web Audio API modern browsers have. The main issue with this library was that it would not work on most mobile browsers, and anywhere else where autoplaying audio was blocked. I tried tinkering with some workarounds, like having some initial user input, but wasn't having much luck. Instead, I decided to use another more full-featured audio library, ToneJS (https://tonejs.github.io/), which contained all the features I needed for audio synthesis and more. ToneJS's implementation of Web Audio does not trigger the autoplay block I was encountering earlier, meaning my web app would work on most browsers, including mobile.


